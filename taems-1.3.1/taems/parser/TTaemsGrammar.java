/* Generated By:JavaCC: Do not edit this line. TTaemsGrammar.java */
package taems.parser;
import java.util.*;
import taems.*;
import utilities.Log;
import utilities.Distribution;

public class TTaemsGrammar implements TTaemsGrammarConstants {

  static final public Taems Input(Log genlog) throws ParseException {
  Token t=null, t2;
  Taems taems = new Taems();
    label_1:
    while (true) {
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECAGENT:
        jj_consume_token(SPECAGENT);
        tt_agent(taems);
        jj_consume_token(RPAREN);
           genlog.log("Read agent");
        break;
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattributetaems(taems);
        jj_consume_token(RPAREN);
        break;
      case SPECTASKGROUP:
        jj_consume_token(SPECTASKGROUP);
        tt_taskgroup(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read taskgroup");
        break;
      case SPECTASK:
        jj_consume_token(SPECTASK);
        tt_task(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read task");
        break;
      case SPECMETHOD:
        jj_consume_token(SPECMETHOD);
        tt_method(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read method");
        break;
      case SPECFACILITATES:
        jj_consume_token(SPECFACILITATES);
        tt_facilitates(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read facilitates");
        break;
      case SPECHINDERS:
        jj_consume_token(SPECHINDERS);
        tt_hinders(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read hinders");
        break;
      case SPECENABLES:
        jj_consume_token(SPECENABLES);
        tt_enables(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read enables");
        break;
      case SPECDISABLES:
        jj_consume_token(SPECDISABLES);
        tt_disables(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read disables");
        break;
      case SPECUSES:
        jj_consume_token(SPECUSES);
        tt_consumes(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read uses");
        break;
      case SPECCONSUMES:
        jj_consume_token(SPECCONSUMES);
        tt_consumes(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read consumes");
        break;
      case SPECLIMITS:
        jj_consume_token(SPECLIMITS);
        tt_limits(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read limits");
        break;
      case SPECPRODUCES:
        jj_consume_token(SPECPRODUCES);
        tt_produces(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read produces");
        break;
      case SPECCRESOURCE:
      case SPECNCRESOURCE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPECCRESOURCE:
          t = jj_consume_token(SPECCRESOURCE);
          break;
        case SPECNCRESOURCE:
          t = jj_consume_token(SPECNCRESOURCE);
          break;
        default:
          jj_la1[0] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        tt_resource(t.image, taems);
        jj_consume_token(RPAREN);
                   genlog.log("Read "+t.image);
        break;
      case SPECCOMMIT:
        jj_consume_token(SPECCOMMIT);
        tt_commitment(taems, false);
        jj_consume_token(RPAREN);
          genlog.log("Read commitment");
        break;
      case SPECNLCOMMIT:
        jj_consume_token(SPECNLCOMMIT);
        tt_commitment(taems, true);
        jj_consume_token(RPAREN);
          genlog.log("Read depricated nonlocal commitment");
        break;
      case SPECSCHED:
        jj_consume_token(SPECSCHED);
        tt_sched(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read schedule");
        break;
      case SPECMLCSCHED:
        jj_consume_token(SPECMLCSCHED);
        tt_mlc_sched(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read mlc_schedule");
        break;
      case SPECEVALCRIT:
        jj_consume_token(SPECEVALCRIT);
        tt_evalcrit(taems);
        jj_consume_token(RPAREN);
          genlog.log("Read eval_criteria");
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
    }
    jj_consume_token(0);
       taems.retargetVirtuals();
       {if (true) return taems;}
    throw new Error("Missing return statement in function");
  }

  static final public void tt_agent(Taems taems) throws ParseException {
   Token t;
   Agent agent = new Agent(null);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LABEL:
        jj_consume_token(LABEL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t = jj_consume_token(ID);
          break;
        case NUM:
          t = jj_consume_token(NUM);
          break;
        default:
          jj_la1[4] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
           agent.setLabel(t.image);
        break;
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattributeagent(agent);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
   taems.addAgent(agent);
  }

  static final public void tt_taskgroup(Taems taems) throws ParseException {
   Token t1,t2,t3;
   Task tg = new Task(null, null, null);;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LABEL:
        jj_consume_token(LABEL);
        t1 = jj_consume_token(ID);
        jj_consume_token(RPAREN);
             tg.setLabel(t1.image);
        break;
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(tg);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[7] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
          tg.setAgent(new Agent(t1.image));
        break;
      case SUBTASKS:
        jj_consume_token(SUBTASKS);
        label_4:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_4;
          }
          t1 = jj_consume_token(ID);
        tg.addSubtask(new VirtualTaskBase(t1.image, null));
        }
        jj_consume_token(RPAREN);
        break;
      case QAF:
        jj_consume_token(QAF);
        t1 = jj_consume_token(ID);
        jj_consume_token(RPAREN);
          if (t1.image.equals("q_max"))
             tg.setQAF(new MaxQAF());
          else if (t1.image.equals("q_min"))
             tg.setQAF(new MinQAF());
          else if (t1.image.equals("q_sum"))
             tg.setQAF(new SumQAF());
          else if (t1.image.equals("q_last"))
             tg.setQAF(new LastQAF());
          else if (t1.image.equals("q_sum_all"))
             tg.setQAF(new SumAllQAF());
          else if (t1.image.equals("q_seq_max"))
             tg.setQAF(new SeqMaxQAF());
          else if (t1.image.equals("q_seq_min"))
             tg.setQAF(new SeqMinQAF());
          else if (t1.image.equals("q_seq_sum"))
             tg.setQAF(new SeqSumQAF());
          else if (t1.image.equals("q_seq_last"))
             tg.setQAF(new SeqLastQAF());
          else if (t1.image.equals("q_exactly_one"))
             tg.setQAF(new ExactlyOneQAF());
          else {
             System.err.println("Warning: Parser does not recognize qaf " + t1.image);
             tg.setQAF(new QAF(t1.image) { });
          }
        break;
      case ARRIVAL:
        jj_consume_token(ARRIVAL);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          tg.setArrivalTime(Integer.valueOf(t1.image).intValue());
        break;
      case EST:
        jj_consume_token(EST);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          tg.setEarliestStartTime(Integer.valueOf(t1.image).intValue());
        break;
      case DEADLINE:
        jj_consume_token(DEADLINE);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          tg.setDeadline(Float.valueOf(t1.image).intValue());
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     taems.addNode(tg);
  }

  static final public void tt_task(Taems taems) throws ParseException {
   Token t1,t2,t3;
   Task t=new Task(null, null, null);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_5;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LABEL:
        jj_consume_token(LABEL);
        t1 = jj_consume_token(ID);
        jj_consume_token(RPAREN);
                  t.setLabel(t1.image);
        break;
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(t);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[11] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
          t.setAgent(new Agent(t1.image));
        break;
      case SUPERTASKS:
        jj_consume_token(SUPERTASKS);
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_6;
          }
          t1 = jj_consume_token(ID);

        }
        jj_consume_token(RPAREN);
        break;
      case SUBTASKS:
        jj_consume_token(SUBTASKS);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_7;
          }
          t1 = jj_consume_token(ID);
        t.addSubtask(new VirtualTaskBase(t1.image, null));
        }
        jj_consume_token(RPAREN);
        break;
      case QAF:
        jj_consume_token(QAF);
        t1 = jj_consume_token(ID);
        jj_consume_token(RPAREN);
          if (t1.image.equals("q_max"))
             t.setQAF(new MaxQAF());
          else if (t1.image.equals("q_min"))
             t.setQAF(new MinQAF());
          else if (t1.image.equals("q_sum"))
             t.setQAF(new SumQAF());
          else if (t1.image.equals("q_last"))
             t.setQAF(new LastQAF());
          else if (t1.image.equals("q_sum_all"))
             t.setQAF(new SumAllQAF());
          else if (t1.image.equals("q_seq_max"))
             t.setQAF(new SeqMaxQAF());
          else if (t1.image.equals("q_seq_min"))
             t.setQAF(new SeqMinQAF());
          else if (t1.image.equals("q_seq_sum"))
             t.setQAF(new SeqSumQAF());
          else if (t1.image.equals("q_seq_last"))
             t.setQAF(new SeqLastQAF());
          else if (t1.image.equals("q_exactly_one"))
             t.setQAF(new ExactlyOneQAF());
          else
             System.err.println("Warning: Parser does not recognize qaf " + t1.image);
        break;
      case ARRIVAL:
        jj_consume_token(ARRIVAL);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setArrivalTime(Integer.valueOf(t1.image).intValue());
        break;
      case EST:
        jj_consume_token(EST);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setEarliestStartTime(Integer.valueOf(t1.image).intValue());
        break;
      case DEADLINE:
        jj_consume_token(DEADLINE);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setDeadline(Float.valueOf(t1.image).intValue());
        break;
      case NONLOCAL:
      case OLDNONLOCAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NONLOCAL:
          jj_consume_token(NONLOCAL);
          break;
        case OLDNONLOCAL:
          jj_consume_token(OLDNONLOCAL);
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
          t.setNonLocal(true);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    taems.addNode(t);
  }

  static final public void tt_method(Taems taems) throws ParseException {
   Token t1,t2,t3;
   Method t = new Method(null, null);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_8;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LABEL:
        jj_consume_token(LABEL);
        t1 = jj_consume_token(ID);
        jj_consume_token(RPAREN);
           t.setLabel(t1.image);
        break;
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(t);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
          t.setAgent(new Agent(t1.image));
        break;
      case SUPERTASKS:
        jj_consume_token(SUPERTASKS);
        label_9:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[18] = jj_gen;
            break label_9;
          }
          t1 = jj_consume_token(ID);

        }
        jj_consume_token(RPAREN);
        break;
      case OUTCOMES:
        jj_consume_token(OUTCOMES);
        label_10:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            ;
            break;
          default:
            jj_la1[19] = jj_gen;
            break label_10;
          }
          ParseOutcome(t);
        }
        jj_consume_token(RPAREN);
        break;
      case ARRIVAL:
        jj_consume_token(ARRIVAL);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setArrivalTime(Integer.valueOf(t1.image).intValue());
        break;
      case EST:
        jj_consume_token(EST);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setEarliestStartTime(Integer.valueOf(t1.image).intValue());
        break;
      case DEADLINE:
        jj_consume_token(DEADLINE);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setDeadline(Float.valueOf(t1.image).intValue());
        break;
      case PCPU:
        jj_consume_token(PCPU);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          Float.valueOf(t1.image).floatValue();
        break;
      case START:
        jj_consume_token(START);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setStartTime(Integer.valueOf(t1.image).intValue());
        break;
      case FINISH:
        jj_consume_token(FINISH);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setFinishTime(Integer.valueOf(t1.image).intValue());
        break;
      case ACCRUED:
        jj_consume_token(ACCRUED);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          t.setAccruedTime(Integer.valueOf(t1.image).intValue());
        break;
      case NONLOCAL:
      case OLDNONLOCAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NONLOCAL:
          jj_consume_token(NONLOCAL);
          break;
        case OLDNONLOCAL:
          jj_consume_token(OLDNONLOCAL);
          break;
        default:
          jj_la1[20] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
          t.setNonLocal(true);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    taems.addNode(t);
  }

  static final public void ParseOutcome(Method m) throws ParseException {
   Token label, t1;
   Outcome newo;
   Distribution d = null,q = null,c = null;
   double density = 1.0;
    jj_consume_token(LPAREN);
    label = jj_consume_token(ID);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_11;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DENSITY:
        jj_consume_token(DENSITY);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
          density = Float.valueOf(t1.image).floatValue();
        break;
      case QDIST:
        jj_consume_token(QDIST);
        q = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case DDIST:
        jj_consume_token(DDIST);
        d = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case CDIST:
        jj_consume_token(CDIST);
        c = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    newo = new Outcome(label.image, q, d, c, (float)density);
    m.addOutcome(newo);
    jj_consume_token(RPAREN);
  }

  static final public Distribution ParseDistribution() throws ParseException {
   Token t1;
   Distribution newd = new Distribution();
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_12;
      }
      t1 = jj_consume_token(NUM);
      newd.addElement(Float.valueOf(t1.image));
    }
      {if (true) return newd;}
    throw new Error("Missing return statement in function");
  }

  static final public void tt_facilitates(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution delay = new Distribution(0,1), qp = null, cp = null, dp = null;
   FacilitatesInterrelationship nle = new FacilitatesInterrelationship(null, null, null, null, null, null);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_13;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case FROMO:
        jj_consume_token(FROMO);
        from_outcome = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case DELAY:
        jj_consume_token(DELAY);
        delay = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case QPOWER:
        jj_consume_token(QPOWER);
        qp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case DPOWER:
        jj_consume_token(DPOWER);
        dp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case CPOWER:
        jj_consume_token(CPOWER);
        cp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Agent a;
  Node fromNode=null, toNode=null;
  Outcome outcome = null;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;

  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setDelay(delay);
  nle.setQuality(qp);
  nle.setDuration(dp);
  nle.setCost(cp);

  if (from_outcome != null)
        outcome = new Outcome(from_outcome.image);
 if (from != null)
        if (from_outcome == null)
                fromNode = new VirtualNode(from.image, null);
        else
                fromNode = new VirtualTaskBase(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);


  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle,outcome,toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_hinders(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution delay = new Distribution(0,1), qp = null, cp = null, dp = null;
   HindersInterrelationship nle = new HindersInterrelationship(null, null,
null, null, null, null);;
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_14;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case FROMO:
        jj_consume_token(FROMO);
        from_outcome = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case DELAY:
        jj_consume_token(DELAY);
        delay = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case QPOWER:
        jj_consume_token(QPOWER);
        qp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case DPOWER:
        jj_consume_token(DPOWER);
        dp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case CPOWER:
        jj_consume_token(CPOWER);
        cp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[30] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Agent a;
  Node fromNode=null, toNode=null;
  Outcome outcome=null;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;

  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setDelay(delay);
  nle.setQuality(qp);
  nle.setDuration(dp);
  nle.setCost(cp);
  if (from_outcome != null)
        outcome = new Outcome(from_outcome.image);
  if (from != null)
        if (from_outcome == null)
                fromNode = new VirtualNode(from.image, null);
        else
                fromNode = new VirtualTaskBase(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);
  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle,outcome,toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_enables(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution delay = new Distribution(0,1), qp = null, cp = null, dp = null;
   EnablesInterrelationship nle = new EnablesInterrelationship(null, null, null);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[31] = jj_gen;
        break label_15;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[32] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case FROMO:
        jj_consume_token(FROMO);
        from_outcome = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case DELAY:
        jj_consume_token(DELAY);
        delay = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Agent a;
  Node fromNode=null, toNode=null;
  Outcome outcome=null;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;

  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setDelay(delay);
  if (from_outcome != null)
        outcome = new Outcome(from_outcome.image);
  if (from != null)
        if (from_outcome == null)
                fromNode = new VirtualNode(from.image, null);
        else
                fromNode = new VirtualTaskBase(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);
  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle,outcome,toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_disables(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution delay = new Distribution(0,1), qp = null, cp = null, dp = null;
   DisablesInterrelationship nle = new DisablesInterrelationship(null, null, null);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_16;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case FROMO:
        jj_consume_token(FROMO);
        from_outcome = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case DELAY:
        jj_consume_token(DELAY);
        delay = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Agent a;
  Node fromNode=null, toNode=null;
  Outcome outcome=null;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;
  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setDelay(delay);
  if (from_outcome != null)
        outcome = new Outcome(from_outcome.image);
  if (from != null)
        if (from_outcome == null)
                fromNode = new VirtualNode(from.image, null);
        else
                fromNode = new VirtualTaskBase(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);
  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle,outcome,toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_limits(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution delay = null, qp = null, cp = null, dp = null;
   String model = Interrelationship.PER_TIME_UNIT;
   LimitsInterrelationship nle = new LimitsInterrelationship(null, null, null, null, null);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_17;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case QPOWER:
        jj_consume_token(QPOWER);
        qp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case DPOWER:
        jj_consume_token(DPOWER);
        dp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case CPOWER:
        jj_consume_token(CPOWER);
        cp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case MODEL:
        jj_consume_token(MODEL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DURATIONINDEPENDENT:
          jj_consume_token(DURATIONINDEPENDENT);
                                         model = Interrelationship.DURATION_INDEPENDENT;
          break;
        case PERTIMEUNIT:
          jj_consume_token(PERTIMEUNIT);
                                          model = Interrelationship.PER_TIME_UNIT;
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Agent a;
  Node fromNode=null, toNode=null;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;

  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setQuality(qp);
  nle.setDuration(dp);
  nle.setCost(cp);
  nle.setModel(model);
  if (from != null)
        fromNode = new VirtualNode(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);
  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle, null, toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_consumes(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution cp = null;
   String model=Interrelationship.PER_TIME_UNIT;
   ConsumesInterrelationship nle = new ConsumesInterrelationship(null, null, null);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_18;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case CONSUMES:
        jj_consume_token(CONSUMES);
        cp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case MODEL:
        jj_consume_token(MODEL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DURATIONINDEPENDENT:
          jj_consume_token(DURATIONINDEPENDENT);
                                         model = Interrelationship.DURATION_INDEPENDENT;
          break;
        case PERTIMEUNIT:
          jj_consume_token(PERTIMEUNIT);
                                          model = Interrelationship.PER_TIME_UNIT;
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Node fromNode=null, toNode=null;
  Agent a;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;

  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setCost(cp);
  nle.setModel(model);
  if (from != null)
        fromNode = new VirtualNode(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);
  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle, null, toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_produces(Taems taems) throws ParseException {
   Token label = null, agent = null, from = null, from_outcome = null, to = null;
   Distribution cp = null;
   String model=Interrelationship.PER_TIME_UNIT;
   ProducesInterrelationship nle  = new ProducesInterrelationship(null, null, null);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_19;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(nle);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          agent = jj_consume_token(ID);
          break;
        case NUM:
          agent = jj_consume_token(NUM);
          break;
        default:
          jj_la1[46] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      case FROM:
        jj_consume_token(FROM);
        from = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case TO:
        jj_consume_token(TO);
        to = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case PRODUCES:
        jj_consume_token(PRODUCES);
        cp = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case MODEL:
        jj_consume_token(MODEL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DURATIONINDEPENDENT:
          jj_consume_token(DURATIONINDEPENDENT);
                                         model = Interrelationship.DURATION_INDEPENDENT;
          break;
        case PERTIMEUNIT:
          jj_consume_token(PERTIMEUNIT);
                                          model = Interrelationship.PER_TIME_UNIT;
          break;
        default:
          jj_la1[47] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[48] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  Agent a;
  Node fromNode=null, toNode=null;
  if (agent != null)
     a = new Agent(agent.image);
  else
     a = null;

  nle.setLabel(label.image);
  nle.setAgent(a);
  nle.setCost(cp);
  nle.setModel(model);
  if (from != null)
        fromNode = new VirtualNode(from.image, null);
  if (to != null)
        toNode = new VirtualNode(to.image, null);
  if ((fromNode != null) && (toNode != null)) {
    fromNode.addInterrelationship(nle, null, toNode);
    taems.addNode(fromNode);
    taems.addNode(toNode);
    }
  else
     System.err.println("Error in parsing Interrelationship " + label.image);
  }

  static final public void tt_resource(String type, Taems taems) throws ParseException {
   Token label = null, from = null, state = null, depleted = null, by=null, overloaded = null;
   Resource newr;
     if (type.equals("spec_consumable_resource"))
       newr = new ConsumableResource(null, null, 0.0, 0.0, 100.0);
     else
       newr = new NonConsumableResource(null, null, 0.0, 0.0, 100.0);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_20;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattribute(newr);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        label = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      case STATE:
        jj_consume_token(STATE);
        state = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
        break;
      case DEPLETEDAT:
        jj_consume_token(DEPLETEDAT);
        depleted = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
        break;
      case OVERLOADEDAT:
        jj_consume_token(OVERLOADEDAT);
        overloaded = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        by = jj_consume_token(ID);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
     if (label != null)
        newr.setLabel(label.image);

     if (state != null)
        newr.setState(Double.valueOf(state.image).doubleValue());

     if (depleted != null)
        newr.setDepletedAt(Double.valueOf(depleted.image).doubleValue());

     if (overloaded != null)
        newr.setOverloadedAt(Double.valueOf(overloaded.image).doubleValue());

     if (by != null)
        newr.setAgent(new Agent(by.image));
     taems.addNode(newr);
  }

  static final public void tt_evalcrit(Taems taems) throws ParseException {
  Token t1;
  Criteria v=new Criteria();
    jj_consume_token(LPAREN);
    jj_consume_token(LABEL);
    t1 = jj_consume_token(ID);
    jj_consume_token(RPAREN);
         v.setLabel(t1.image);
    jj_consume_token(LPAREN);
    jj_consume_token(GOODNESSQS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setGoodnessQuality(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(GOODNESSCS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setGoodnessCost(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(GOODNESSDS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setGoodnessDuration(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(THRESHQS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setThresholdQuality(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(THRESHCS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setThresholdCost(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(THRESHDS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setThresholdDuration(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(QTHRESH);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setQualityThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(CLIMIT);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setCostThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(DLIMIT);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setDurationThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(UNCERTAINQS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setUncertaintyQuality(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(UNCERTAINCS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setUncertaintyCost(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(UNCERTAINDS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setUncertaintyDuration(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(THRESHCERTQS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setThresholdCertaintyQuality(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(THRESHCERTCS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setThresholdCertaintyCost(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(THRESHCERTDS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setThresholdCertaintyDuration(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(QUALCERTTHRESH);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setQualityCertaintyThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(COSTCERTTHRESH);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setCostCertaintyThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(DURCERTTHRESH);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setDurationCertaintyThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(METAGS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setMetaGoodness(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(METATS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setMetaThreshold(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(METAUS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setMetaUncertainty(Float.valueOf(t1.image));
    jj_consume_token(LPAREN);
    jj_consume_token(METAUTS);
    t1 = jj_consume_token(NUM);
    jj_consume_token(RPAREN);
         v.setMetaUncertaintyThreshold(Float.valueOf(t1.image));
        taems.setScheduleCriteria(v);
  }

/*
	  v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <GOODNESSCS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <GOODNESSDS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <THRESHQS> t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <THRESHCS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <THRESHDS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}	
   <LPAREN> <QTHRESH> t1=<NUM> <RPAREN>
	{v.insertElementAt(Float.valueOf(t1.image),0);}
   <LPAREN> <CLIMIT>  t1=<NUM> <RPAREN>
	{v.insertElementAt(Float.valueOf(t1.image),1);}
   <LPAREN> <DLIMIT>  t1=<NUM> <RPAREN>
	{v.insertElementAt(Float.valueOf(t1.image),2);}	
   <LPAREN> <UNCERTAINQS> t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <UNCERTAINCS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <UNCERTAINDS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <THRESHCERTQS> t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <THRESHCERTCS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <THRESHCERTDS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}	
   <LPAREN> <QUALCERTTHRESH> t1=<NUM> <RPAREN>
	{v.insertElementAt(Float.valueOf(t1.image),3);}
   <LPAREN> <COSTCERTTHRESH>  t1=<NUM> <RPAREN>
	{v.insertElementAt(Float.valueOf(t1.image),4);}
   <LPAREN> <DURCERTTHRESH>  t1=<NUM> <RPAREN>
	{v.insertElementAt(Float.valueOf(t1.image),5);}	
   <LPAREN> <METAGS> t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <METATS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <METAUS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));}
   <LPAREN> <METAUTS>  t1=<NUM> <RPAREN>
	{v.addElement(Float.valueOf(t1.image));
	taems.setScheduleCriteria(v);
*/
  static final public void tt_mlc_sched(Taems taems) throws ParseException {
   Token t1,t2;
   MLCSchedule s = new MLCSchedule();
   Schedule ss;
   ScheduleElement se;
   Vector tempvec;
   Vector sched_els, task_qual, commit_info, qd, dd, cd;
    jj_consume_token(LPAREN);
    jj_consume_token(SCHEDULES);
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_21;
      }
      jj_consume_token(LPAREN);
      jj_consume_token(SPECSCHED);
      ss = tt_sched(null);
      jj_consume_token(RPAREN);
           s.addScheduleSimple(ss);
    }
    jj_consume_token(RPAREN);
    jj_consume_token(LPAREN);
    jj_consume_token(SCHEDELEMS);
                         tempvec = new Vector();
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_22;
      }
      se = tt_sched_elem();
           s.addScheduleElement(se);
    }
    jj_consume_token(RPAREN);
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[53] = jj_gen;
        break label_23;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASKQINFOS:
        jj_consume_token(TASKQINFOS);
                   tempvec = new Vector();
        label_24:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[54] = jj_gen;
            break label_24;
          }
          t1 = jj_consume_token(ID);
          t2 = jj_consume_token(NUM);
          tempvec.addElement(t1.image);
          tempvec.addElement(Integer.decode(t2.image));
        }
         s.setTaskQualityInfo(tempvec);
        jj_consume_token(RPAREN);
        break;
      case COMMITINFO:
        jj_consume_token(COMMITINFO);
                   tempvec = new Vector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[55] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          tempvec.addElement(t1.image);
         s.setCommitmentInfo(tempvec);
        jj_consume_token(RPAREN);
        break;
      case STARTDIST:
        jj_consume_token(STARTDIST);
                  s.setStart(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case FINISHDIST:
        jj_consume_token(FINISHDIST);
                   s.setFinish(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case QDIST:
        jj_consume_token(QDIST);
               s.setQuality(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case DDIST:
        jj_consume_token(DDIST);
               s.setDuration(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case CDIST:
        jj_consume_token(CDIST);
               s.setCost(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case RATING:
        jj_consume_token(RATING);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
               s.setRating(Double.valueOf(t1.image).doubleValue());
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    s.fixConditions(null);
    taems.addSchedule(s);
  }

  static final public Schedule tt_sched(Taems taems) throws ParseException {
   Token t1,t2;
   Schedule s = new Schedule();
   ScheduleElement se;
   Vector tempvec;
   Vector sched_els, task_qual, commit_info, qd, dd, cd;
    jj_consume_token(LPAREN);
    jj_consume_token(SCHEDELEMS);
                         tempvec = new Vector();
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_25;
      }
      se = tt_sched_elem();
           s.addScheduleElement(se);
    }
    jj_consume_token(RPAREN);
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[58] = jj_gen;
        break label_26;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TASKQINFOS:
        jj_consume_token(TASKQINFOS);
                   tempvec = new Vector();
        label_27:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[59] = jj_gen;
            break label_27;
          }
          t1 = jj_consume_token(ID);
          t2 = jj_consume_token(NUM);
          tempvec.addElement(t1.image);
          tempvec.addElement(Integer.decode(t2.image));
        }
         s.setTaskQualityInfo(tempvec);
        jj_consume_token(RPAREN);
        break;
      case COMMITINFO:
        jj_consume_token(COMMITINFO);
                   tempvec = new Vector();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
          tempvec.addElement(t1.image);
         s.setCommitmentInfo(tempvec);
        jj_consume_token(RPAREN);
        break;
      case STARTDIST:
        jj_consume_token(STARTDIST);
                  s.setStart(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case FINISHDIST:
        jj_consume_token(FINISHDIST);
                   s.setFinish(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case QDIST:
        jj_consume_token(QDIST);
               s.setQuality(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case DDIST:
        jj_consume_token(DDIST);
               s.setDuration(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case CDIST:
        jj_consume_token(CDIST);
               s.setCost(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case RATING:
        jj_consume_token(RATING);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
               s.setRating(Double.valueOf(t1.image).doubleValue());
        break;
      default:
        jj_la1[61] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    s.fixConditions(null);
    if (taems != null)
      taems.addSchedule(s);
    {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

  static final public ScheduleElement tt_sched_elem() throws ParseException {
   Token t1,t2;
   String label;
   Distribution st = null, ft = null, qd = null, dd = null, cd = null;
   Vector qm = null, dm = null;
   Vector prev = new Vector();
   Precondition pre;
   ScheduleElement dum = new ScheduleElement();
    jj_consume_token(LPAREN);
    t1 = jj_consume_token(ID);
       label = t1.image;
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_28;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattributescheduleelement(dum);
        jj_consume_token(RPAREN);
        break;
      case STARTDIST:
        jj_consume_token(STARTDIST);
        st = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case FINISHDIST:
        jj_consume_token(FINISHDIST);
        ft = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case QDIST:
        jj_consume_token(QDIST);
        qd = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case DDIST:
        jj_consume_token(DDIST);
        dd = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case CDIST:
        jj_consume_token(CDIST);
        cd = ParseDistribution();
        jj_consume_token(RPAREN);
        break;
      case QMON:
        jj_consume_token(QMON);
              qm = new Vector();
        label_29:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NUM:
            ;
            break;
          default:
            jj_la1[63] = jj_gen;
            break label_29;
          }
          t1 = jj_consume_token(NUM);
          qm.addElement(Integer.decode(t1.image));
        }
        jj_consume_token(RPAREN);
        break;
      case DMON:
        jj_consume_token(DMON);
              dm = new Vector();
        label_30:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NUM:
            ;
            break;
          default:
            jj_la1[64] = jj_gen;
            break label_30;
          }
          t1 = jj_consume_token(NUM);
          dm.addElement(Integer.decode(t1.image));
        }
        jj_consume_token(RPAREN);
        break;
      case PRECONS:
        jj_consume_token(PRECONS);
        label_31:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case LPAREN:
            ;
            break;
          default:
            jj_la1[65] = jj_gen;
            break label_31;
          }
          pre = tt_precon();
                                     prev.addElement(pre);
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(RPAREN);
    ScheduleElement se = new ScheduleElement(new VirtualMethod(label, null), st, ft, qd, dd, cd, qm, dm);
    if (prev.size() > 0) se.setPreconditions(prev);
    Enumeration e = dum.getAttributes();
    while (e.hasMoreElements()) {
       Object key = e.nextElement();
       se.setAttribute(key, dum.getAttribute(key));
    }
    {if (true) return se;}
    throw new Error("Missing return statement in function");
  }

  static final public Precondition tt_precon() throws ParseException {
   Token t;
   Distribution q;
   VirtualInterrelationship i;
   ScheduleElement se;
   Precondition p;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EARLIESTPRE:
      jj_consume_token(EARLIESTPRE);
      jj_consume_token(LPAREN);
      jj_consume_token(EST);
      q = ParseDistribution();
      jj_consume_token(RPAREN);
        p = new EarliestStartTimePrecondition(null, q);
      break;
    case PRECPRE:
      jj_consume_token(PRECPRE);
      jj_consume_token(LPAREN);
      jj_consume_token(SCHEDELEM);
      t = jj_consume_token(ID);
      jj_consume_token(RPAREN);
                                               se = new ScheduleElement(); se.setMethod(new VirtualMethod(t.image, null));
      jj_consume_token(LPAREN);
      jj_consume_token(INTERRELATIONSHIP);
      t = jj_consume_token(ID);
      jj_consume_token(RPAREN);
                                                       i = new VirtualInterrelationship(t.image, null);
        p = new PrecedencePrecondition(null, se, i);
      break;
    default:
      jj_la1[67] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
     {if (true) return p;}
    throw new Error("Missing return statement in function");
  }

  static final public Hashtable tt_realspecattribute() throws ParseException {
 Token t1, t2=null, t3=null;
 Object o;
 String text="";
 Hashtable h = new Hashtable();
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_32;
      }
      jj_consume_token(LPAREN);
      t1 = tt_get_next_token();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        t3 = jj_consume_token(ID);
        break;
      case NUM:
        t3 = jj_consume_token(NUM);
        break;
      default:
        jj_la1[69] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DELIM:
      case NUM:
      case ID:
      case SPECIAL:
        label_33:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DELIM:
            ;
            break;
          default:
            jj_la1[70] = jj_gen;
            break label_33;
          }
          jj_consume_token(DELIM);
          t2 = jj_consume_token(SPECIAL);
        }
        text = readText();
        jj_consume_token(RPAREN);
        break;
      case RPAREN:
         text = null;
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[71] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    if (t2 != null) {
       text = "DELIM"+ t2.image + " " + text;
       t2 = null;
    }

    if ((text == null) || (text.trim().length() == 0)) {
       text = t3.image;
       t3.image="String";
    }

    o = utilities.Converter.reTypeProperty(text, t3.image);

    if (o != null)
      h.put(t1.image, o);
    else if (t3.image.equalsIgnoreCase("Node"))
      h.put(t1.image, new VirtualNode(text));
    else
      h.put(t1.image, text);
    }
     {if (true) return h;}
    throw new Error("Missing return statement in function");
  }

  static final public void tt_specattribute(Node n) throws ParseException {
 Token t1, t2=null, t3;
 Object o;
 String text="";
        Hashtable h = tt_realspecattribute();
        Enumeration e = h.keys();
        while (e.hasMoreElements()) {
                Object k = e.nextElement();
                o = h.get(k);
                n.setAttribute(k,o);
        }
  }

  static final public String readText() throws ParseException {
Token t2;
String text="", tmp="";
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        t2 = jj_consume_token(ID);
       if (tmp.equals(""))
         tmp = t2.image;
       else
          tmp = tmp + " " + t2.image;
        break;
      case NUM:
        t2 = jj_consume_token(NUM);
       if (tmp.equals(""))
         tmp = t2.image;
       else
          tmp = tmp + " " + t2.image;
        break;
      case SPECIAL:
        t2 = jj_consume_token(SPECIAL);
        if (text.equals(""))
           if (tmp.equals(""))
              text = t2.image;
           else {
              text = tmp.trim() + t2.image;
              tmp = "";
              }
       else if(tmp.equals(""))
              text = text + t2.image;
           else {
              text = text + tmp.trim() + t2.image;
              tmp = "";
                }
        break;
      default:
        jj_la1[72] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case ID:
      case SPECIAL:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_34;
      }
    }
   {if (true) return(text+tmp.trim());}
    throw new Error("Missing return statement in function");
  }

  static final public void tt_specattributetaems(Taems t) throws ParseException {
 Token t1, t2=null, t3;
 Object o;
 String text="";
        Hashtable h = tt_realspecattribute();
        Enumeration e = h.keys();
        while (e.hasMoreElements()) {
                Object k = e.nextElement();
                o = h.get(k);
                t.setAttribute(k,o);
        }
  }

  static final public void tt_specattributecommitment(Commitment com) throws ParseException {
 Token t1, t2=null, t3;
 String text="";
 Object o;
        Hashtable h = tt_realspecattribute();
        Enumeration e = h.keys();
        while (e.hasMoreElements()) {
                Object k = e.nextElement();
                o = h.get(k);
                com.setAttribute(k,o);
        }
  }

  static final public void tt_specattributescheduleelement(ScheduleElement se) throws ParseException {
 Token t1, t2=null, t3;
 String text="";
 Object o;
        Hashtable h = tt_realspecattribute();
        Enumeration e = h.keys();
        while (e.hasMoreElements()) {
                Object k = e.nextElement();
                o = h.get(k);
                se.setAttribute(k,o);
        }
  }

  static final public void tt_specattributeagent(Agent a) throws ParseException {
 Token t1, t2=null, t3;
 String text="";
 Object o;
        Hashtable h = tt_realspecattribute();
        Enumeration e = h.keys();
        while (e.hasMoreElements()) {
                Object k = e.nextElement();
                o = h.get(k);
                a.setAttribute(k,o);
        }
  }

  static final public void tt_commitment(Taems taems, boolean nl) throws ParseException {
   Token t1;
   Vector tmpTask = new Vector();
   Commitment commitment = new Commitment();
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_35;
      }
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECATTRIBUTES:
        jj_consume_token(SPECATTRIBUTES);
        tt_specattributecommitment(commitment);
        jj_consume_token(RPAREN);
        break;
      case LABEL:
        jj_consume_token(LABEL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[75] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
           commitment.setLabel(t1.image);
        break;
      case TYPE:
        jj_consume_token(TYPE);
        t1 = tt_get_next_token();
        jj_consume_token(RPAREN);
           commitment.setType(t1.image);
        break;
      case AGENT:
        jj_consume_token(AGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
           commitment.setFromAgent(new Agent(t1.image));
        break;
      case FROMAGENT:
        jj_consume_token(FROMAGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[77] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
           commitment.setFromAgent(new Agent(t1.image));
        break;
      case TOAGENT:
        jj_consume_token(TOAGENT);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ID:
          t1 = jj_consume_token(ID);
          break;
        case NUM:
          t1 = jj_consume_token(NUM);
          break;
        default:
          jj_la1[78] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(RPAREN);
           commitment.setToAgent(new Agent(t1.image));
        break;
      case TASK:
        jj_consume_token(TASK);
        label_36:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ID:
            ;
            break;
          default:
            jj_la1[79] = jj_gen;
            break label_36;
          }
          t1 = jj_consume_token(ID);
                    tmpTask.addElement(new VirtualTaskBase(t1.image, null));
        }
        jj_consume_token(RPAREN);
            commitment.setTaskVector(tmpTask);
        break;
      case IMPORTANCE:
        jj_consume_token(IMPORTANCE);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setImportance(Integer.valueOf(t1.image).intValue());
        break;
      case MINQ:
        jj_consume_token(MINQ);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setMinimumQuality(Float.valueOf(t1.image).floatValue());
        break;
      case EST:
        jj_consume_token(EST);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setEarliestStartTime(Integer.valueOf(t1.image).intValue());
        break;
      case DEADLINE:
        jj_consume_token(DEADLINE);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setDeadline(Float.valueOf(t1.image).intValue());
        break;
      case DIS:
        jj_consume_token(DIS);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setDontIntervalStart(Integer.valueOf(t1.image).intValue());
        break;
      case DIE:
        jj_consume_token(DIE);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setDontIntervalEnd(Integer.valueOf(t1.image).intValue());
        break;
      case SAT:
        jj_consume_token(SAT);
        t1 = jj_consume_token(NUM);
        jj_consume_token(RPAREN);
           commitment.setTimeSatisfied(Integer.valueOf(t1.image).intValue());
        break;
      case QDIST:
        jj_consume_token(QDIST);
                   commitment.setQualityDistribution(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case TDIST:
        jj_consume_token(TDIST);
                   commitment.setTimeDistribution(ParseDistribution());
        jj_consume_token(RPAREN);
        break;
      case NONLOCAL:
      case OLDNONLOCAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NONLOCAL:
          jj_consume_token(NONLOCAL);
          break;
        case OLDNONLOCAL:
          jj_consume_token(OLDNONLOCAL);
          break;
        default:
          jj_la1[80] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                      commitment.setNonLocal(true);
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[81] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if (nl) commitment.setNonLocal(true);
    taems.addCommitment(commitment);
  }

  static Token tt_get_next_token() throws ParseException {
   return getNextToken();
  }

  static private boolean jj_initialized_once = false;
  static public TTaemsGrammarTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  static public Token token, jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[82];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x280a00,0x80,0x80,0x0,0x400,0x80,0x0,0x0,0x3f400,0x80,0x0,0x0,0x0,0x0,0x13f400,0x80,0x0,0x0,0x80,0x0,0xe0539400,0x80,0x7800000,0x0,0x80,0x0,0x1400,0x80,0x0,0x1400,0x80,0x0,0x1400,0x80,0x0,0x1400,0x80,0x0,0x0,0x1400,0x80,0x0,0x0,0x1400,0x80,0x0,0x0,0x1400,0x80,0x1400,0x80,0x80,0x80,0x0,0x0,0x17000000,0x80,0x80,0x0,0x0,0x17000000,0x80,0x0,0x0,0x80,0x7000000,0x0,0x80,0x0,0x40000,0x40100,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x9031400,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x18000,0x3001ff0c,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x101,0x0,0x0,0x0,0x0,0x0,0xe0001f0,0x0,0x0,0xe0001f0,0x0,0x0,0x1f0,0x0,0x0,0x1f0,0x0,0x0,0xc0000,0xe020160,0x0,0x0,0xc0000,0x20160,0x0,0x0,0xc0000,0x20160,0x0,0x1c00100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000100,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x0,0x2000300,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x198000,0x0,0x0,0x0,0x0,0x198000,0x0,0x0,0x0,0x0,0x79000,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7c,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0xc00000,0x0,0x0,0xc00000,0x800000,0x0,0x0,0xc00000,0x800000,0x800000,0x300000,0x300000,0x0,0xc00000,0x800000,0x0,0x300000,0x300000,0x0,0x0,0x400000,0x0,0xc00000,0x0,0x0,0xc00000,0x0,0x0,0xc00000,0x0,0x0,0xc00000,0x0,0x0,0xc00000,0x0,0x0,0x0,0xc00000,0x0,0x10000,0x0,0xc00000,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x800000,0xc00000,0x0,0x0,0x0,0x800000,0xc00000,0x0,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,0xc00000,0x0,0x1c00000,0x1c00000,0x1c00000,0x0,0xc00000,0xc00000,0xc00000,0xc00000,0x800000,0x300000,0x3c0000,};
   }

  public TTaemsGrammar(java.io.InputStream stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TTaemsGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 82; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 82; i++) jj_la1[i] = -1;
  }

  public TTaemsGrammar(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TTaemsGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 82; i++) jj_la1[i] = -1;
  }

  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 82; i++) jj_la1[i] = -1;
  }

  public TTaemsGrammar(TTaemsGrammarTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  You must");
      System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 82; i++) jj_la1[i] = -1;
  }

  public void ReInit(TTaemsGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 82; i++) jj_la1[i] = -1;
  }

  static final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.Vector jj_expentries = new java.util.Vector();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  static public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[121];
    for (int i = 0; i < 121; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 82; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 121; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  static final public void enable_tracing() {
  }

  static final public void disable_tracing() {
  }

}
